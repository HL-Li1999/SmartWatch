# 概述

本项目使用imx6ull制作音视频播放器，主要功能包括以下几个方面：

（1）图像界面：通过**文件I/O操作**读取JPG格式的图片文件，并利用**Libjpeg图像解码库**对这些图片进行解码处理。

（2）LCD控制：为了实现更加流畅和响应迅速的界面更新，我采用**内存映射**技术直接访问LCD设备文件。

（3）视频文件管理：为了方便用户浏览和选择视频内容，我设计并实现了基于**双向链表**的视频文件信息管理系统。支持用户通过滑动浏览的方式轻松选择想要播放的视频文件，大大增强了应用的可用性和互动性。

（4）多进程通信：为了实时监控视频播放进程的状态并获取播放信息，使用了**有名管道**和**消息队列**两种IPC机制。

（5）多线程同步控制：为了确保全屏/非全屏模式下触摸事件的准确捕获和处理，使用**信号量**实现线程同步，使用**互斥锁**和**条件变量**确保线程只在必要时刻运行以节省CPU资源。

# 图像界面

## 文件I/O

通过文件I/O操作读取JPG格式的图片文件，以及视频文件。

文件I/O读取任意目录下文件的步骤如下：

（1）定义目录指针、目录实体指针、文件流。

（2）使用opendir()打开目录，获得指定目录的目录指针。

（3）使用readdir()依次打开目录下的文件。

（4）通过dtype和文件名判断文件类型。

（4）使用fopen()打开文件，得到文件流。

```C
(1).
DIR* dir_ptr; //目录指针
struct dirent* dirent_ptr; //目录实体指针
FILE* file;	//文件流
char file_path[50]; //文件路径

(2).
dir_ptr = opendir("./material");

(3).
while(1)
{
	dirent_ptr = readdir(dir_ptr);
	if(dirent_ptr == NULL){	//注意写上此循环终止条件
        break;
    }
    
    (4).
    if(dirent_ptr->d_type == DIR_REG) //普通文件
    {
        if(strstr(dirent_ptr->d_name, ".mp4") != NULL) //MP4文件
        {
            (5).
             sprintf(file_path, "./material/%s", dirent_ptr->d_name);
             file = fopen(file_path, "rb");
        }
    }   
}
```

## Libjpeg库解码JPG图片

按以下流程编写，最后可以解码得到图片的高度、宽度、通道数、像素数据。

```C
struct jpeg_decompress_struct cinfo; //用于获取解码信息
struct jpeg_error_mgr jerr; //用于保存解码过程中的错误信息

cinfo.err = jpeg_std_error(&jerr); //关联解码信息对象和错误信息对象
jpeg_create_decompress(&cinfo);    //初始化解码信息对象

jpeg_stdio_src(&cinfo, infile); //指定要解码的图像文件
jpeg_read_header(&cinfo, TRUE); //获取图像信息
jpeg_start_decompress(&cinfo);	//开始解码

uint32_t jpeg_width = cinfo.output_width;	 //解码信息：图像宽度
uint32_t jpeg_height = cinfo.output_height;	 //解码信息：图像高度
uint32_t jpeg_components = cinfo.components; //解码信息：图像通道数

usigned char* buffer = malloc(jpeg_width * jpeg_height * jpeg_components);//存储像素数据
while(cinfo.output_scanline < jpeg_height)
{
	usigned char* buffer_line[1]; //用于指示当前扫描线首地址
    buffer_line[0] = buffer + (cinfo.output_scanline) * jpeg_width * jpeg_components;
    jpeg_read_scanlines(&cinfo,  		//解压对象
                    	&buffer_line,	//解码的图片像素信息存放的地址
                    	1 				//读取多少行数据来解压
                    	);	    
}

jpeg_finish_decompress(&cinfo);  //结束解码
jpeg_destroy_decompress(&cinfo); //释放解码信息对象
free(buffer);
```

# LCD控制

通过内存映射直接访问LCD设备文件。本项目使用的LCD为RGB565格式，因此还需要将3个通道的像素值进行整合转换为RGB565格式。

## 内存映射

Linux的内存映射机制是一种高效的内存管理技术，它允许进程的虚拟地址空间与物理内存之间建立直接的映射关系。

mmap函数将一个文件或者其它对象映射到进程的地址空间，使得进程可以像访问普通内存一样访问文件内容。这种映射关系建立后，进程就可以通过指针的方式对映射的内存区域进行读写操作，而系统会自动将修改过的脏页面回写到对应的文件磁盘上，从而完成了对文件的操作，而无需再调用read、write等系统调用函数。在对文件进行频繁读写操作时，可以使用内存读写取代I/O读写，从而获得较高的性能。

（1）使用open()打开要映射的文件，得到文件标识符。

（2）使用mmap()进行内存映射，得到内存映射地址。

（3）通过该地址可以进行数据读取和写入。

（4）解除内存映射，关闭文件。

```C
int fd; //文件标识符
uint16_t* fd_ptr; //被映射区的指针
unsigned int size = 100; //映射区的长度

(1).
lcd_fd = open("/dev/fb0", O_RDWR);

(2).
fd_ptr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, lcd_fd, 0);

(3).
*fd_ptr = 0x12; //文件的第一个字节写入0x12

(4).
munmap(lcd_fd, size);
close(lcd_fd);
```

# 视频文件管理

## 双向链表结构

视频文件信息包括：封面图片信息，视频文件路径，视频文件类型。采用Linux的双向链表结构表示视频文件之间的关系，步骤如下：

（1）将视频文件信息设置为结构体，并添加一个双向链表成员，通过该成员来表示视频文件之间的关系。

（2）遍历所有视频文件，将对应的视频文件信息结构体的链表成员，添加到链表的尾部。

（3）通过该链表表示视频文件之间的关系，Linux的双向链表结构体 `list_head` 作为其它结构体的成员时，可通过 `list_entry()` 获取整个结构体信息。

# 多进程通信

**在非全屏时同时共存两个进程**：

- 主进程：创建主线程、读非全屏触摸屏指令线程、写MPlayer指令线程、读MPlayer信息线程。
- MPlayer进程：通过MPlayer在显示区域播放视频，当选择播放另外一个视频或者滑动进度条时，会销毁之前的进程，重新打开一个MPlayer进程。



**在全屏时同时共存三个进程**：

- 主进程：创建主线程、读非全屏触摸屏指令线程、写MPlayer指令线程、读MPlayer信息线程。
- 子进程：当触摸屏点击“进入全屏”按键时，从主进程分离出来的子进程。该进程创建读全屏触摸屏指令线程。

- MPlayer进程：销毁原来非全屏的MPlayer进程，创建一个新的全屏MPlayer进程。


## 进程操作

新建进程的步骤如下：

（1）使用 `fork()` 或者 `vfork()` 创建子进程。

（2）如果要启动其它程序，使用 `execlp()` 启动，启动的新进程会替换原来的进程。

（3）在子进程结束时使用 `exit()` 退出进程。

（4）在父进程中使用 `wait()` 或 `waitpid()` 等待子进程结束，回收子进程。

```C
pid_t pid = fork();
if(pid == 0)
{
	execlp("mplayer", "mplayer", "./video/mo1.mp4");
	exit(0);
}
waitpid(pid, NULL, 0);
```

## 有名管道

**有名管道的使用步骤如下**：

（1）使用 `mkfifo()` 创建有名管道。

（2）使用 `open()` 打开管道文件。

（3）使用 `read()` 和 `write()` 读取或写入管道内容。

```C
#define MYFIFO "./myfifo" //命名管道文件名和路径

(1).
if(access(MYFIFO, F_OK)) //检查管道文件是否存在，存在返回0，不存在返回-1
{
	mkfifo(MYFIFO, 0777);
}

(2).
int fd = open(MYFIFO, O_RDONLY);

(3).
char buff[] = "this is a fifo test demo";
int nwrite = write(fd, buff, strlen(buff));
int nread = read(fd, buff, sizeof(buff));
```



**标准输出重定向**

**Linux重定向：**是指修改原来系统命令的默认执行方式，将原本要输出的数据信息重新指向某个特定的文件中，或者将输入的数据信息从指定的文件中读取。

**Linux标准输出：**是一个预定义的文件描述符，用于将程序或命令的正常输出结果发送到某个地方。在大多数情况下，标准输出会被定向到终端（命令行界面），这样用户就可以直接看到程序的输出内容。

**如何获得标准输出内容：**可通过 `dup2()` 将标准输出文件描述符重定向到另一个文件（比如管道文件），通过 `read()` 读取该文件从而获得标准输出内容。

```C
int fd = open("./myfifo", O_RDWR);
dup2(fd, STDOUT_FILENO);

char buff[50];
int nread = read(fd, buff, sizeof(buff));
```



**有名管道用于和MPlayer通信**

在本项目中，主进程和MPlayer进程通信使用了两个有名管道，一个用于主进程读MPlayer进程写，一个用于主进程写MPlayer进程读。整体步骤如下：

（1）创建两个管道用于主进程读和主进程写，步骤如上述。

（2）在启动MPlayer程序前将标准输出重定向到读管道。

（3）主进程通过 `read()` 读取该管道内容，获得MPlayer输出的消息。

（4）在启动MPlayer程序时将写管道作为输入。

（5）主进程通过 `write()` 向该管道写入内容，MPlayer进程会自动读取管道内容，从而向MPlayer发送消息。

```c
pid_t pid = fork();
if(pid == 0)
{
    (2).
    int fifo_read = open("./myfifo_read", O_RDWR);
    dup2(fifo_read, STDOUT_FILENO);
    
    (4).  
    //slave指mplayer以slave模式运行，这允许通过FIFO（命名管道）或其他方式控制mplayer
	execlp("mplayer","mplayer","slave","quiet","input","file=/tmp/videoplayer/myfifo",
		"-geometry","0:0","-zoom","-x","610","-y","370","./video/mo1.mp4",NULL);
	exit(0);
}

//以下皆在主进程中
(3).
char buff_read[50];
int nread = read(fifo_read, buff_read, sizeof(buff));

(4).
char buff_write[] = "get_percent_pos\n";
int nwrite = write(fifo_write, buff_write, strlen(buff_write));
```

## 消息队列

**消息队列介绍**：

消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 相较于管道，消息队列有以下特点：

- 在命名管道中，发送数据用write()，接收数据用read()。在消息队列中，发送数据用msgsnd()，接收数据用msgrcv()，消息队列对每个数据都有一个最大长度的限制。
- 管道只能承载无格式字节流。消息队列提供有格式的字节流，可以减少了开发人员的工作量。
- 命名管道读取数据采用先进先出原则。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级，接收程序可以通过消息类型有选择地接收数据。



**本项目使用消息队列的原因**：

在点击了全屏按钮后，将全屏标志位置1，新建一个子进程用于处理识别全屏的触摸屏事件。

由于父进程是按识别结果进行操作，因此子进程需要将识别结果发送给父进程。

通过消息队列来实现这两个进程之间的通信。



**消息队列的使用步骤如下**：

（1）创建一个表示消息队列传输内容的结构体，成员包括消息的类型（自己定义，可以按数字分类）和消息内容（可以为任意类型的对象）。

（2）`ftok()` 生成唯一的键值，用于标识消息队列。

（3）一个进程使用 `msgget()` 创建消息队列，另一个进程使用 `msgget()` 打开消息队列。

（4）一个进程使用 `msgsnd()` 发送信息。

（5）一个进程使用 `msgrcv()` 接收信息。

```C
(1).
typedef struct MsgBuf
{
    long mtype;
    int mcontent;
}msgbuf_t;
    
(2).        
key_t key = ftok(".", 1);

(3).
//主进程
int msgid = msgget(key, IPC_CREAT|0666);	//创建消息队列
//子进程
key_t key = ftok(".", 1);
int msgid = msgget(key, IPC_CREAT|0666);	//打开消息队列

(4).
//子进程
msgbuf_t msg_snd_buf;
msg_snd_buf.mtype = 1;
msg_snd_buf.mcontent = right_up; //枚举量，表示右侧向上滑动
msgsnd(msgid, &msg_snd_buf, sizeof(msg_snd_buf.mcontent), 0);

(5).
//主进程
msgbuf_t msg_rcv_buf;
msgrcv(msgid, &msg_rcv_buf, sizeof(msg_rcv_buf.mcontent), 1, 0);
```

# 多线程通信

## 线程操作

**线程的操作步骤如下**：

（1）使用 `pthread_create()` 创建线程。

（2）线程中使用 `pthread_exit()` 退出线程。

（3）其它线程使用 `pthread_join()` 回收线程。

```C
(1).
pthread_t write_command_tid; 	//用于向MPlayer发送信息的线程
pthread_crate(&write_command_tid, NULL, thread_fun, NULL);

void* thread_fun(void* arg)
{
    //....
    
    (2).
    pthread_exit(NULL);
}

(3).
//主线程
pthread_join(write_command_tid, NULL);
```



**本项目共包含5个线程**：

首先触摸屏操作共包含三个步骤：读取触摸屏事件 → 识别触摸屏事件类型 → 按事件类型进行相应操作。

通过两个线程来实现触摸屏操作：

- 线程1/2：读取全屏/非全屏触摸屏事件，并在手指松开时识别触摸屏事件类型。
- 主线程0：按事件类型进行相应操作。

然后主进程和MPlayer进程的通信包含两个部分：主进程写管道MPlayer读管道，主进程读管道MPlayer写管道，按MPlayer发送的消息进行相应操作。

通过三个线程来实现和MPlayer通信：

- 线程3：主进程向管道中写入消息，需要一直写入的消息为“获取进度信息”，其余如暂停等在主线程按事件类型进程相应操作时发送。
- 线程4：主进程读取管道消息，需要一直获得的消息为“进度信息”，读取完毕后马上按该消息进行相应操作（即调整进度条位置），没有别的消息需要读取。

## 信号量

**有名信号量使用步骤**

（1）使用 `sem_open()` 创建有名信号量。

（2）在另外的线程使用 `sem_open()` 打开已创建的有名信号量。

（3）使用 `sem_post()` 释放有名信号量。

（4）使用 `sem_wait()` 阻塞等待获取信号量。

```C
#define SEMNAME "semname"

//主线程
(1).
sem_t* sem;
sem = sem_open(SEMNAME, O_CREAT, 0777, 0);

(4).
sem_wait(sem);

//子线程
(2).
sem_t* sem;
sem = sem_open(SEMNAME, O_CREAT, 0777, 0);

(3).
sem_post(sem);
```



**本项目使用信号量进行线程同步的方法**

线程1/2和主线程0应该为同步关系，因为只有在读取到新的触摸屏事件后才可以进行操作，如果在没有读取到新的触摸屏事件时依然持续操作触摸屏事件，操作的内容仍然是之前读取到的触摸屏事件。

线程3和线程4应该为同步关系，只有在写入信息后才应该读取新的信息。且应该为写读写读...，如果是写写写读读读，则读到的都是最后一次写的，进度条会发生跳变看起来卡顿。

以线程3和线程4的同步关系为例，使用步骤如下：

（1）创建两个信号量，分别用于控制主进程写操作和读操作，初始阶段释放一个写操作。

（2）线程3（写线程）等待获取写信号量，在写操作完毕后释放读信号量。

（3）线程4（读线程）等待获取读信号量，在读操作完毕后释放写信号量。

```C
(1).
sem_t *get_video_percent_read_sem;
get_video_percent_read_sem = sem_open(MAIN_PERCENT_SEMNAME_READ, O_CREAT, 0777, 0);
sem_t *get_video_percent_write_sem;
get_video_percent_write_sem = sem_open(MAIN_PERCENT_SEMNAME_WRITE, O_CREAT, 0777, 0);

(2).
void* write_command(const void* arg)
{
	sem_t *get_video_percent_read_sem;
	get_video_percent_read_sem = sem_open(MAIN_PERCENT_SEMNAME_READ, O_CREAT, 0777, 0);
	sem_t *get_video_percent_write_sem;
	get_video_percent_write_sem = sem_open(MAIN_PERCENT_SEMNAME_WRITE, O_CREAT, 0777, 0);
	while(1)
	{
		sem_wait(get_video_percent_write_sem);
		//写操作...
		sem_post(get_video_percent_read_sem);
	}
}

(3).
void* get_video_info(const void *arg)
{
    sem_t *get_video_percent_read_sem;
	get_video_percent_read_sem = sem_open(MAIN_PERCENT_SEMNAME_READ, O_CREAT, 0777, 0);
	sem_t *get_video_percent_write_sem;
	get_video_percent_write_sem = sem_open(MAIN_PERCENT_SEMNAME_WRITE, O_CREAT, 0777, 0);
	while(1)
	{
		sem_wait(get_video_percent_read_sem);
		//写操作...
		sem_post(get_video_percent_write_sem);
	}
}
```

## 条件变量+互斥锁

**为什么条件变量要和互斥锁联合使用**

通过与互斥锁结合使用，可以确保在条件变量等待和唤醒的过程中，对临界区资源的访问是互斥的，从而避免数据竞争和不一致性。



**条件变量的使用步骤**

（1）使用 `pthread_cond_init()` 初始化条件变量、使用 `pthread_mutex_init()` 初始化互斥锁。

（2）使用 `pthread_mutex_wait()` 上锁。

（3）使用 `pthread_cond_wait()` 等待标志位符合条件。

（4）使用 `pthread_mutex_unlock()` 解锁。

```C
(1).
pthread_cond_t g_write_command_v;//暂停/播放允许向mplayer发送指令条件变量
pthread_mutex_t g_write_command_m;//暂停/播放允许向mplayer发送指令标志位
pthread_mutex_init(&g_write_command_m,NULL);
pthread_cond_init(&g_write_command_v,NULL);

(2).
pthread_mutex_lock(&g_main_instruction_m);

(3).
while(g_wFull_screen_flg != 0) //0 非全屏 1全屏
{   
    pthread_cond_wait(&g_main_instruction_v,&g_main_instruction_m);
}

(4).
pthread_mutex_unlock(&g_main_instruction_m);
```



**本项目使用条件变量+互斥锁的原因**

线程1、2只有满足非全屏/全屏情况下才需要执行，同样的线程3、4也只需要在视频播放时才需要进行，因为在视频暂停时，不用更新视频进度，此时这两个线程可以阻塞以释放CPU资源。

但是线程在启动后就会一直执行，若采用一个标志位来表示视频播放和暂停，线程函数持续判断标志位，在符合条件时执行，在不符合条件时使用sleep()阻塞。这样会导致 **忙等待** 和 **资源占用**。

采用**条件变量**可以避免上述问题，对这个标志位配上一个条件变量和互斥锁，在不符合条件时线程阻塞获取条件变量，条件变量在标志位变为符合条件时释放。

整体使用步骤如上所示，在按下“全屏”按键时标志位 `g_wFull_screen_flg` 置1，从而使线程2进入等待阶段。




